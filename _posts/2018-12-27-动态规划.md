---
layout:     post
date:       2018-12-27
author:     penny
catalog: true
tags:
    - 算法
---

# 9.12 什么是动态规划

## 斐波那契数列

时间复杂度：2^n，时间是指数级增长。递归树如下：有多次重复计算。即：**重叠子结构问题**

<figure>
<a><img src="{{site.url}}/assets/1542619244460.png"></a>
</figure>

对于n=20，执行了2w次fib函数。n=40，执行了300w

- 递归求斐波那契数列

```java
// 递归求斐波那契数列
public class Solution1 {
    private int num = 0;

    public int fib( int n ){
        num ++;
        if( n == 0 )
            return 0;
        if( n == 1 )
            return 1;

        return fib(n-1) + fib(n-2);
    }

    public int getNum(){
        return num;
    }

    public static void main(String[] args) {
        int n = 42;

        Solution1 solution = new Solution1();
        long startTime = System.currentTimeMillis();
        int res = solution.fib(n);
        long endTime = System.currentTimeMillis();

        System.out.println("fib(" + n + ") = " + res);
        System.out.println("time : " + (endTime - startTime) + " ms");
        System.out.println("run function fib() " + solution.getNum() + " times.");
    }
}
```

- 记忆化搜索

记忆化搜索--自上而下的解决问题。更容易

```java
import java.util.Arrays;

// 记忆化搜索
public class Solution2 {
    private int num = 0;

    public int fib(int n){
        int[] memo = new int[n + 1];
        Arrays.fill(memo, -1);
        return fib(n, memo);
    }

    private int fib(int n, int[] memo){
        num ++;
        if(n == 0)
            return 0;
        if(n == 1)
            return 1;
        
        if(memo[n] == -1)
            memo[n] = fib(n - 1, memo) + fib(n - 2, memo);
        return memo[n];
    }

    public int getNum(){
        return num;
    }

    public static void main(String[] args) {
        //int n = 42;
        int n = 1000; // 注意: 我们使用n = 1000只是为了测试性能, 实际上会溢出.斐波那契额数列是以指数速度上涨的.所以这个结果是错误的
        Solution2 solution = new Solution2();
        long startTime = System.currentTimeMillis();
        int res = solution.fib(n);
        long endTime = System.currentTimeMillis();

        System.out.println("fib(" + n + ") = " + res);
        System.out.println("time : " + (endTime - startTime) + " ms");
        System.out.println("run function fib() " + solution.getNum() + " times.");
    }
}
```

- 动态规划

自下而上的解决问题。先解决小数据量问题的结果，再解决大数据情况下的结果。

性能比记忆化搜素更好：

1.没有递归调用，省时间、空间。

2.memo只访问了一次

```java
import java.util.Arrays;

// 动态规划
public class Solution3 {
    public int fib(int n){
        int[] memo = new int[n + 1];
        Arrays.fill(memo, -1);

        memo[0] = 0;
        memo[1] = 1;
        for(int i = 2 ; i <= n ; i ++)
            memo[i] = memo[i - 1] + memo[i - 2];

        return memo[n];
    }

    public static void main(String[] args) {
        //int n = 42;
        int n = 1000; // 注意: 我们使用n = 1000只是为了测试性能, 实际上会溢出
        // 斐波那契额数列是以指数速度上涨的

        Solution3 solution = new Solution3();
        long startTime = System.currentTimeMillis();
        int res = solution.fib(n);
        long endTime = System.currentTimeMillis();

        System.out.println("fib(" + n + ") = " + res);
        System.out.println("time : " + (endTime - startTime) + " ms");
    }
}
```

## 什么是动态规划

<figure>
<a><img src="{{site.url}}/assets/1542620239234.png"></a>
</figure>

动态规划的本质和记忆化搜索是一样的。一般记忆化搜索的答案是能够满足的。有时候记忆搜索的答案也会是一个动态规划的答案。有一类递归问题有重叠子结构问题,转化为动态规划

<figure>
<a><img src="{{site.url}}/assets/1542620310939.png"></a>
</figure>

## 70.climbing  stairs

<figure>
<a><img src="{{site.url}}/assets/1542620420446.png"></a>
</figure>

### 递归：自顶向下

<figure>
<a><img src="{{site.url}}/assets/1542620554285.png"></a>
</figure>

### 普通递归

```java
import java.util.Arrays;

public class Solution1 {
    private int calcWays(int n){
        if(n == 1)
            return 1;
        if(n == 2)
            return 2;

        return calcWays(n - 1) + calcWays(n - 2);
    }

    public static void main(String[] args) {

        System.out.println((new Solution1()).calcWays(10));
    }
}
```

递归终止的条件也可以是如下：这样n=2传进去后会自动算出来。

```java
private int calcWays(int n){
    // 没有台阶可以走，就一种方式
    if(n == 0)
        return 1;
    if(n == 1)
        return 2;

    return calcWays(n - 1) + calcWays(n - 2);
}
```

### 记忆化搜索

```java
import java.util.Arrays;

public class Solution1 {
    private int[] memo;

    public int climbStairs(int n) {
        memo = new int[n+1];
        Arrays.fill(memo, -1);
        return calcWays(n);
    }

    private int calcWays(int n){
        if(n == 0 || n == 1)
            return 1;
		//没有计算过
        if(memo[n] == -1)
            memo[n] = calcWays(n - 1) + calcWays(n - 2);

        return memo[n];
    }

    public static void main(String[] args) {
        System.out.println((new Solution1()).climbStairs(10));
    }
}
```

### 动态规划

```java
/// 70. Climbing Stairs
/// https://leetcode.com/problems/climbing-stairs/description/
/// 动态规划
/// 时间复杂度: O(n)
/// 空间复杂度: O(n)
public class Solution2 {

    public int climbStairs(int n) {
        int[] memo = new int[n + 1];
        memo[0] = 1;
        memo[1] = 1;
        for(int i = 2 ; i <= n ; i ++)
            memo[i] = memo[i - 1] + memo[i - 2];
        return memo[n];
    }

    public static void main(String[] args) {
        System.out.println((new Solution2()).climbStairs(10));
    }
}
```

## 练习

120 reiangle

64 minimum path sum

题目中限定每个格子包含一个非负整数，每一步只能左移或下移。这两个问题是对题目能够使用动态规划求解有限定的。

# 9.3 发现重叠子问题

## 343 Integer Break

<figure>
<a><img src="{{site.url}}/assets/1542621564759.png"></a>
</figure>

### 暴力解决

由于将n分成几份不知道，所以不知道要分几重循环。所以用回溯遍历找出一个数做分割的所有可能性。（O(2^n)）。

比如分割4：蓝色的是重叠子问题，可以用记忆化搜索

<figure>
<a><img src="{{site.url}}/assets/1542621870917.png"></a>
</figure>

分割n：res(n) = x * res(n-x)

<figure>
<a><img src="{{site.url}}/assets/1542621957033.png"></a>
</figure>

### 最优子结构

之所以可以用这样的递归结构去解决问题，就是因为**通过求得子问题的最优解，能够求得原问题的最优解。即：最优子结构**（针对优化问题）

即：一个递归问题同时有重叠子问题结构 & 最优子结构 就能采用动态规划。

<figure>
<a><img src="{{site.url}}/assets/1542622165925.png"></a>
</figure>

- 暴力答案（breakInteger是至少将n-i分割两部分，所以还要考虑不分割n-i）

```java
/// 343. Integer Break
/// https://leetcode.com/problems/integer-break/description/
/// 暴力搜索
/// 在Leetcode中提交这个版本的代码会超时! (Time Limit Exceeded)
/// 时间复杂度: O(n^n)
/// 空间复杂度: O(n)
public class Solution1 {
    public int integerBreak(int n) {
        if(n < 1)
            throw new IllegalArgumentException("n should be greater than zero");
        return breakInteger(n);
    }

    // 将n进行分割(至少分割两部分), 可以获得的最大乘积
    private int breakInteger(int n){
        if(n == 1)
            return 1;

        int res = -1;
        for(int i = 1 ; i <= n - 1 ; i ++)
            //breakInteger分为至少两部分，但还有一种情况就是i*(n-i)
            res = max3(res, i * (n - i), i * breakInteger(n - i));
        return res;
    }

    private int max3(int a, int b, int c){
        return Math.max(a, Math.max(b, c));
    }

    public static void main(String[] args) {
        System.out.println((new Solution1()).integerBreak(2));
        System.out.println((new Solution1()).integerBreak(10));
    }
}
```

- 记忆化搜索，自顶向下

```java
import java.util.Arrays;

/// 343. Integer Break
/// https://leetcode.com/problems/integer-break/description/
/// 记忆化搜索
/// 时间复杂度: O(n^2)
/// 空间复杂度: O(n)
public class Solution2 {
    private int[] memo;

    public int integerBreak(int n) {
        if(n < 1)
            throw new IllegalArgumentException("n should be greater than zero");

        memo = new int[n+1];
        Arrays.fill(memo, -1);

        return breakInteger(n);
    }

    // 将n进行分割(至少分割两部分), 可以获得的最大乘积
    private int breakInteger(int n){
        if(n == 1)
            return 1;

        if(memo[n] != -1)
            return memo[n];

        int res = -1;
        for(int i = 1 ; i <= n - 1 ; i ++)
            res = max3(res, i * (n - i) , i * breakInteger(n - i));
        // 记录结果
        memo[n] = res;
        return res;
    }

    private int max3(int a, int b, int c){
        return Math.max(a, Math.max(b, c));
    }

    public static void main(String[] args) {
        System.out.println((new Solution2()).integerBreak(2));
        System.out.println((new Solution2()).integerBreak(10));
    }
}
```

- 动态规划，自底向上

```java
/// 343. Integer Break
/// https://leetcode.com/problems/integer-break/description/
/// 动态规划
/// 时间复杂度: O(n^2)
/// 空间复杂度: O(n)
public class Solution3 {
    public int integerBreak(int n) {
        if(n < 1)
            throw new IllegalArgumentException("n should be greater than zero");

        int[] memo = new int[n+1];
        memo[1] = 1;
        for(int i = 2 ; i <= n ; i ++)
            // 求解memo[i]
            for(int j = 1 ; j <= i - 1 ; j ++)
                memo[i] = max3(memo[i], j * (i - j), j * memo[i - j]);

        return memo[n];
    }

    private int max3(int a, int b, int c){
        return Math.max(a, Math.max(b, c));
    }

    public static void main(String[] args) {
        System.out.println((new Solution3()).integerBreak(2));
        System.out.println((new Solution3()).integerBreak(10));
    }
}
```

## 练习

279  perfect squares

91 decode ways

62 unique paths

63 unique pathsII

# 9.4 状态的定义和状态转移

## 198 House Robber

<figure>
<a><img src="{{site.url}}/assets/1542701526113.png"></a>
</figure>

### 暴力法

<figure>
<a><img src="{{site.url}}/assets/1542701595196.png"></a>
</figure>

最优化问题-可能有最优子结构。

- 首先：考虑偷0；不偷0，偷1；不偷0,1,偷2.。。

<figure>
<a><img src="{{site.url}}/assets/1542701883561.png"></a>
</figure>

紧接着：发现该问题有最优子结构，重叠子问题

<figure>
<a><img src="{{site.url}}/assets/1542701913055.png"></a>
</figure>

<figure>
<a><img src="{{site.url}}/assets/1542702068241.png"></a>
</figure>

**f函数的定义**只是：**考虑**，而不是一定。所以不一定会在该范围内偷。

v就表示要偷取这个编号的房子。

状态：定义了函数要做什么

状态转移方程：函数怎么做

```java
import java.util.Arrays;

/// 198. House Robber
/// https://leetcode.com/problems/house-robber/description/
/// 暴力
/// 时间复杂度: O(n^2)
/// 空间复杂度: O(n)
public class Solution1 {
    public int rob(int[] nums) {
        return tryRob(nums, 0);
    }

    // 考虑抢劫nums[index...nums.size())这个范围的所有房子
    private int tryRob(int[] nums, int index){
        if(index >= nums.length)
            return 0;

        int res = 0;
        for(int i = index ; i < nums.length ; i ++)
            res = Math.max(res, nums[i] + tryRob(nums, i + 2));
        return res;
    }

    public static void main(String[] args) {
        int nums[] = {2, 1};
        System.out.println((new Solution1()).rob(nums));
    }
}
```

### 记忆化搜索

```java
import java.util.Arrays;

/// 198. House Robber
/// https://leetcode.com/problems/house-robber/description/
/// 记忆化搜索
/// 时间复杂度: O(n^2)
/// 空间复杂度: O(n)
public class Solution1 {
    // memo[i] 表示考虑抢劫 nums[i...n) 所能获得的最大收益
    private int[] memo;

    public int rob(int[] nums) {
        memo = new int[nums.length];
        Arrays.fill(memo, -1);
        return tryRob(nums, 0);
    }

    // 考虑抢劫nums[index...nums.size())这个范围的所有房子
    private int tryRob(int[] nums, int index){
        if(index >= nums.length)
            return 0;

        if(memo[index] != -1)
            return memo[index];

        int res = 0;
        for(int i = index ; i < nums.length ; i ++)
            res = Math.max(res, nums[i] + tryRob(nums, i + 2));
        memo[index] = res;
        return res;
    }

    public static void main(String[] args) {
        int nums[] = {2, 1};
        System.out.println((new Solution1()).rob(nums));
    }
}
```

### 动态规划:自底向上

```java
import java.util.Arrays;

/// 198. House Robber
/// https://leetcode.com/problems/house-robber/description/
/// 动态规划
/// 时间复杂度: O(n^2)
/// 空间复杂度: O(n)
public class Solution2 {
    public int rob(int[] nums) {
        int n = nums.length;
        if(n == 0)
            return 0;

        // memo[i] 表示考虑抢劫 nums[i...n) 即 nums[i...n-1] 所能获得的最大收益
        int[] memo = new int[nums.length];
        // i=n-1是最基础的情况，要考虑数组越界，所以n >= 1,前面要判断n=0时的情况
        memo[n - 1] = nums[n - 1];
        for(int i = n - 2 ; i >= 0 ; i --)
            // memo[i]
            for (int j = i; j < n; j++)
                memo[i] = Math.max( memo[i],nums[j] + (j + 2 < n ? memo[j + 2] : 0));
		
        // 最大的情况
        return memo[0];
    }

    public static void main(String[] args) {
        int nums[] = {2, 1};
        System.out.println((new Solution2()).rob(nums));
    }
}
```

### 改变状态

<figure>
<a><img src="{{site.url}}/assets/1542704153307.png"></a>
</figure>

## 练习

213  house robberII

337  house robberIII

309 best time to buy and sell stock with cooldown

# 9.56 0-1背包问题

## 0-1背包问题

<figure>
<a><img src="{{site.url}}/assets/1542704478339.png"></a>
</figure>

### 暴力解法

还是一个最优解问题，解空间是组合。组合问题都可以用递归去解，看能不能找到重叠子问题和最优子结构去解。

<figure>
<a><img src="{{site.url}}/assets/1542704589364.png"></a>
</figure>

状态：递归函数的参数，递归函数要做什么。参数的个数意味着解决问题要满足的约束条件。本题目有两个约束条件，n个物品，放入容量为C的背包。

<figure>
<a><img src="{{site.url}}/assets/1542705022726.png"></a>
</figure>

### 记忆化搜索

**// 因为这个问题有两个约束条件，每个状态由两个变量决定。所以memo是一个二维数组**

```java
/// 背包问题
/// 记忆化搜索
/// 时间复杂度: O(n * C) 其中n为物品个数; C为背包容积
/// 空间复杂度: O(n * C)
public class Solution1 {
    // 因为这个问题有两个约束条件，每个状态由两个变量决定。
    private int[][] memo;

    public int knapsack01(int[] w, int[] v, int C){
        if(w == null || v == null || w.length != v.length)
            throw new IllegalArgumentException("Invalid w or v");

        if(C < 0)
            throw new IllegalArgumentException("C must be greater or equal to zero.");

        int n = w.length;
        if(n == 0 || C == 0)
            return 0;

        memo = new int[n][C + 1];
        return bestValue(w, v, n - 1, C);
    }

    // 用 [0...index]的物品,填充容积为c的背包的最大价值
    private int bestValue(int[] w, int[] v, int index, int c){
		// 容量不够或者Index不对，就返回
        if(c <= 0 || index < 0)
            return 0;
		// 计算过
        if(memo[index][c] != -1)
            return memo[index][c];
		// 不放最后一个
        int res = bestValue(w, v, index-1, c);
        // 放最后一个，放的话要考虑容量够不够，容量够再放。
        if(c >= w[index])
            res = Math.max(res, v[index] + bestValue(w, v, index - 1, c - w[index]));

        return memo[index][c] = res;
    }

    public static void main(String[] args) {
    }
}
```

模拟填充过程：

1. 三行表示3个物品，六列表示容量。最后的答案就是arr\[2][5].

<figure>
<a><img src="{{site.url}}/assets/1542706077664.png"></a>
</figure>

1. 根据递推公式依次去填表

   <figure>
   <a><img src="{{site.url}}/assets/1542706271232.png"></a>
   </figure>

2. 最后得到结果

   <figure>
   <a><img src="{{site.url}}/assets/1542706463966.png"></a>
   </figure>

### 贪心解法

<figure>
<a><img src="{{site.url}}/assets/1542704745817.png"></a>
</figure>

如上所示，先放0,1.就没有地方放3了，所以这个是局部最优解，但本题求的是全局最优解。

### 动态规划

```java
/// 背包问题
/// 动态规划
/// 时间复杂度: O(n * C) 其中n为物品个数; C为背包容积
/// 空间复杂度: O(n * C)
public class Solution2 {
    public int knapsack01(int[] w, int[] v, int C){
        if(w == null || v == null || w.length != v.length)
            throw new IllegalArgumentException("Invalid w or v");

        if(C < 0)
            throw new IllegalArgumentException("C must be greater or equal to zero.");
		
        //排除不正确的情况
        int n = w.length;
        if(n == 0 || C == 0)
            return 0;

        int[][] memo = new int[n][C + 1];
		// 初始化，先填充第一行，考虑第一个物品能否放进去。j是当前背包容量。这里因为确保了有一个物品，所以前面要先判断一下有几个物品
        for(int j = 0 ; j <= C ; j ++)
            memo[0][j] = (j >= w[0] ? v[0] : 0 );
		
        // 
        for(int i = 1 ; i < n ; i ++)
            for(int j = 0 ; j <= C ; j ++){
                memo[i][j] = memo[i-1][j];
                if(j >= w[i])
                    memo[i][j] = Math.max(memo[i][j], v[i] + memo[i - 1][j - w[i]]);
            }

        return memo[n - 1][C];
    }

    public static void main(String[] args) {

    }
}
```

<figure>
<a><img src="{{site.url}}/assets/1542707100376.png"></a>
</figure>

## 0-1背包优化

### 使用2行完成

<figure>
<a><img src="{{site.url}}/assets/1542707143096.png"></a>
</figure>

可以开辟两行i,i+1，在计算下一行i+2的时候就占用i即可。所以可以发现这两行中有一行总是在处理物品编号为奇数时的情况，另一行总是在处理物品编号为偶数时的情况。所以所有行都要%2。

极大的扩展了能处理的问题规模n

```java
/// 背包问题
/// 动态规划改进: 滚动数组
/// 时间复杂度: O(n * C) 其中n为物品个数; C为背包容积
/// 空间复杂度: O(C), 实际使用了2*C的额外空间
public class Solution1 {
    public int knapsack01(int[] w, int[] v, int C){

        if(w == null || v == null || w.length != v.length)
            throw new IllegalArgumentException("Invalid w or v");

        if(C < 0)
            throw new IllegalArgumentException("C must be greater or equal to zero.");

        int n = w.length;
        if(n == 0 || C == 0)
            return 0;

        int[][] memo = new int[2][C + 1];

        for(int j = 0 ; j <= C ; j ++)
            memo[0][j] = (j >= w[0] ? v[0] : 0);

        for(int i = 1 ; i < n ; i ++)
            for(int j = 0 ; j <= C ; j ++){
                memo[i % 2][j] = memo[(i-1) % 2][j];
                if(j >= w[i])
                    memo[i % 2][j] = Math.max(memo[i % 2][j], v[i] + memo[(i-1) % 2][j - w[i]]);
            }

        return memo[(n-1) % 2][C];
    }

    public static void main(String[] args) {
    }
}
```

### 使用一行完成

对于每一行的更新，其实只用了原来一行对应位置和该位置左边的数据。所以可以从右向左更新这一行。

i=0这一行

<figure>
<a><img src="{{site.url}}/assets/1542707805524.png"></a>
</figure>

更新i=1这一行。已经更新了c=5,现在更新c=4.

<figure>
<a><img src="{{site.url}}/assets/1542707784801.png"></a>
</figure>

使用这个方法，还能使得算法提前终止，所以不仅节省了空间，也节省了时间。

```java
/// 背包问题
/// 动态规划改进
/// 时间复杂度: O(n * C) 其中n为物品个数; C为背包容积
/// 空间复杂度: O(C), 只使用了C的额外空间
public class Solution2 {
    public int knapsack01(int[] w, int[] v, int C){

        if(w == null || v == null || w.length != v.length)
            throw new IllegalArgumentException("Invalid w or v");

        if(C < 0)
            throw new IllegalArgumentException("C must be greater or equal to zero.");

        int n = w.length;
        if(n == 0 || C == 0)
            return 0;

        int[] memo = new int[C+1];
		// 初始化
        for(int j = 0 ; j <= C ; j ++)
            memo[j] = (j >= w[0] ? v[0] : 0);
		//对于列，是从后往前
        for(int i = 1 ; i < n ; i ++)
            // j<w[i]的时候就不能放了，就是左边没修改的部分
            for(int j = C ; j >= w[i] ; j --)
                memo[j] = Math.max(memo[j], v[i] + memo[j - w[i]]);

        return memo[C];
    }

    public static void main(String[] args) {
    }
}
```

## 可能的变种问题

完全背包问题：每个物品可以无限使用。（背包容量有限，所以每个物品能放的数量是有限的，转换为有限数量问题；对任意一个数字而言，都可以用一个二进制码来表示，可以用1,2,4,8代表1,1,1）

多重背包问题：每个物品不止1个，有num(i)个

多维费用背包问题：考虑物品的体积、重量两个维度。

物品间加入更多约束：互相排斥或者互相依赖。

# 9.7 面试中的0-1背包问题

## 416 Partition Equal Subset Sum

<figure>
<a><img src="{{site.url}}/assets/1542708936242.png"></a>
</figure>

其实这是一个典型的背包问题：注意要完全填满

<figure>
<a><img src="{{site.url}}/assets/1542709119748.png"></a>
</figure>

根据题目中的约束条件计算出，复杂度为100万。是能够在1s内算出来的，所以思路正确。

<figure>
<a><img src="{{site.url}}/assets/1542709163654.png"></a>
</figure>

### 记忆化搜索

```java
import java.util.Arrays;

/// 416. Partition Equal Subset Sum
/// https://leetcode.com/problems/partition-equal-subset-sum/description/
/// 记忆化搜索
/// 时间复杂度: O(len(nums) * O(sum(nums)))
/// 空间复杂度: O(len(nums) * O(sum(nums)))
public class Solution {
    // memo[i][c] 表示使用索引为[0...i]的这些元素,是否可以完全填充一个容量为c的背包
    // -1 表示为未计算; 0 表示不可以填充; 1 表示可以填充
    private int[][] memo;

    public boolean canPartition(int[] nums) {
        int sum = 0;
        for(int i = 0 ; i < nums.length ; i ++){
            if(nums[i] <= 0)
                throw new IllegalArgumentException("numbers in nums must be greater than zero.");
            sum += nums[i];
        }

        if(sum % 2 == 1)
            return false;
	   // 初始化
        memo = new int[nums.length][sum / 2 + 1];
        for(int i = 0 ; i < nums.length ; i ++)
            Arrays.fill(memo[i], -1);
        return tryPartition(nums, nums.length - 1, sum / 2);
    }

    // 使用nums[0...index], 是否可以完全填充一个容量为sum的背包
    private boolean tryPartition(int[] nums, int index, int sum){
        if(sum == 0)
            return true;

        if(sum < 0 || index < 0)
            return false;

        if(memo[index][sum] != -1)
            return memo[index][sum] == 1;
	   //这两种情况有一个正确就行
        memo[index][sum] = (tryPartition(nums, index - 1, sum) ||
                tryPartition(nums, index - 1, sum - nums[index])) ? 1 : 0;

        return memo[index][sum] == 1;
    }

    private static void printBool(boolean res){
        System.out.println(res ? "True" : "False");
    }

    public static void main(String[] args) {
        int[] nums1 = {1, 5, 11, 5};
        printBool((new Solution1()).canPartition(nums1));

        int[] nums2 = {1, 2, 3, 5};
        printBool((new Solution1()).canPartition(nums2));
    }
}
```

### 动态规划

```java
import java.util.Arrays;

/// 416. Partition Equal Subset Sum
/// https://leetcode.com/problems/partition-equal-subset-sum/description/
/// 动态规划
/// 时间复杂度: O(len(nums) * O(sum(nums)))
/// 空间复杂度: O(len(nums) * O(sum(nums)))
public class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for(int i = 0 ; i < nums.length ; i ++){
            if(nums[i] <= 0)
                throw new IllegalArgumentException("numbers in nums must be greater than zero.");
            sum += nums[i];
        }

        if(sum % 2 == 1)
            return false;

        int n = nums.length;
        int C = sum / 2;
		// 因为动态规划是从小到大，所以肯定是未计算过的。所以要先初始化为false。然后计算第一行。
        //这里的动态规划采用最优的方法，只用一个一维数组进行更新。
        boolean[] memo = new boolean[C + 1];
        for(int i = 0 ; i <= C ; i ++)
            memo[i] = (nums[0] == i); 
		
        // 因为复用了数组，所以注意不能覆盖掉当前数组未被改变的值，所以要从后往前考虑第i个物品，每次多考虑一个物品。即：dp[i,c] = dp[i-1,c] || dp[i-1,c-wi]. 现在是dp[c] = dp[c] || dp[c-wi]。当前数组还是i-1时候的值，所以从后往前修改
        for(int i = 1 ; i < n ; i ++)
            for(int j = C; j >= nums[i] ; j --)
                memo[j] = memo[j] || memo[j - nums[i]];

        return memo[C];
    }

    private static void printBool(boolean res){
        System.out.println(res ? "True" : "False");
    }

    public static void main(String[] args) {
        int[] nums1 = {1, 5, 11, 5};
        printBool((new Solution2()).canPartition(nums1));

        int[] nums2 = {1, 2, 3, 5};
        printBool((new Solution2()).canPartition(nums2));
    }
}
```

## 练习

322  coin change

377 combination sum IV

474 ones and zeroes

<figure>
<a><img src="{{site.url}}/assets/1542710334497.png"></a>
</figure>

139 word break ❤

494 target sum（本质是一个2^n的解空间问题）

# 9.8 LIS问题

## 300.LIS最长递增子序列

<figure>
<a><img src="{{site.url}}/assets/1542710541434.png"></a>
</figure>

暴力解：解空间是给定元素的组合。所以可以用递归做

<figure>
<a><img src="{{site.url}}/assets/1542710868207.png"></a>
</figure>

关注当选择一个数字后能发生什么，但选择后位置不固定不好。所以给这个数字一个特殊位置。即：

<figure>
<a><img src="{{site.url}}/assets/1542711101064.png"></a>
</figure>

## 动态规划

```java
import java.util.Arrays;

/// 300. Longest Increasing Subsequence
/// https://leetcode.com/problems/longest-increasing-subsequence/description/
/// 记忆化搜索
/// 时间复杂度: O(n^2)
/// 空间复杂度: O(n)
public class Solution2 {
    public int lengthOfLIS(int[] nums) {
        if(nums.length == 0)
            return 0;

        // memo[i] 表示以 nums[i] 为结尾的最长上升子序列的长度
        int memo[] = new int[nums.length];
        Arrays.fill(memo, 1);
        for(int i = 1 ; i < nums.length ; i ++)
            for(int j = 0 ; j < i ; j ++)
                if(nums[i] > nums[j])
                    memo[i] = Math.max(memo[i], 1 + memo[j]);

        int res = memo[0];
        for(int i = 1 ; i < nums.length ; i ++)
            res = Math.max(res, memo[i]);

        return res;
    }

    public static void main(String[] args) {
        int nums4[] = {1, 3, 6, 7, 9, 4, 10, 5, 6};
        System.out.println((new Solution2()).lengthOfLIS(nums4));
    }
}
```

## 记忆化搜索

```java
import java.util.Arrays;

/// 300. Longest Increasing Subsequence
/// https://leetcode.com/problems/longest-increasing-subsequence/description/
/// 记忆化搜索
/// 时间复杂度: O(n^2)
/// 空间复杂度: O(n)
public class Solution1 {
    private int[] memo;
    
    public int lengthOfLIS(int[] nums) {
        if(nums.length == 0)
            return 0;

        memo = new int[nums.length];
        Arrays.fill(memo, -1);
        int res = 1;
        for(int i = 0 ; i < nums.length ; i ++)
            res = Math.max(res, getMaxLength(nums, i));

        return res;
    }

    // 以 nums[index] 为结尾的最长上升子序列的长度
    private int getMaxLength(int[] nums, int index){
        if(memo[index] != -1)
            return memo[index];

        int res = 1;
        for(int i = 0 ; i <= index-1 ; i ++)
            if(nums[index] > nums[i])
                res = Math.max(res, 1 + getMaxLength(nums, i));

        return memo[index] = res;
    }

    public static void main(String[] args) {
        int nums4[] = {1, 3, 6, 7, 9, 4, 10, 5, 6};
        System.out.println((new Solution1()).lengthOfLIS(nums4));
    }
}
```

## 练习

376 wiggle subsequence

# 9.9 LCS，最短路，求DP的具体解以及更多

## LCS最长公共子序列

典型的从两个维度进行动态规划的问题，因为要在两个字符串中进行扫描。

<figure>
<a><img src="{{site.url}}/assets/1542718850611.png"></a>
</figure>

<figure>
<a><img src="{{site.url}}/assets/1542719319184.png"></a>
</figure>

dijkstra单源最短路径算法也是动态规划算法

<figure>
<a><img src="{{site.url}}/assets/1542719434809.png"></a>
</figure>

溯源：

0-1背包的溯源就不能只用一维数组了，因为要一步步往回推。
